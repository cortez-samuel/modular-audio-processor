// ---------------------------------------------------------------- //
// This file is autogenerated by pioasm version 2.2.0; do not edit! //
// ---------------------------------------------------------------- //

#pragma once

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

// --------------- //
// SPI_Byte_Master //
// --------------- //

#define SPI_Byte_Master_wrap_target 0
#define SPI_Byte_Master_wrap 1
#define SPI_Byte_Master_pio_version 0

static const uint16_t SPI_Byte_Master_program_instructions[] = {
            //     .wrap_target
    0x6001, //  0: out    pins, 1         side 0
    0x5001, //  1: in     pins, 1         side 1
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program SPI_Byte_Master_program = {
    .instructions = SPI_Byte_Master_program_instructions,
    .length = 2,
    .origin = -1,
    .pio_version = SPI_Byte_Master_pio_version,
#if PICO_PIO_VERSION > 0
    .used_gpio_ranges = 0x0
#endif
};

static inline pio_sm_config SPI_Byte_Master_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + SPI_Byte_Master_wrap_target, offset + SPI_Byte_Master_wrap);
    sm_config_set_sideset(&c, 1, false, false);
    return c;
}

#include "hardware/clocks.h"
static inline void SPI_Byte_Master_init(
        PIO pio, uint sm, uint offset,
        uint SCLK_pin, uint MOSI_pin, uint MISO_pin, uint CS_pin,
        uint baud,
        bool full_duplex
) {
        // get default config
    pio_sm_config c = SPI_Byte_Master_program_get_default_config(offset);
        // set in/out pins and shifts
    sm_config_set_out_pins(&c, MOSI_pin, 1);
    sm_config_set_in_pins(&c, MISO_pin);
    sm_config_set_in_pin_count(&c, 1);
    sm_config_set_sideset_pins(&c, SCLK_pin);
    sm_config_set_out_shift(&c, false, true, 8);
    sm_config_set_in_shift(&c, false, full_duplex, 8);
        // set clkdiv
    float clkdiv = clock_get_hz(clk_sys) / (baud * 8.0 * 2.0);
    sm_config_set_clkdiv(&c, clkdiv);
        // initialize pins
    uint32_t pin_mask = (1 << SCLK_pin) | (1 << MOSI_pin) | (1 << MISO_pin);
    uint32_t pindir_mask = (1 << SCLK_pin) | (1 << MOSI_pin) | (0 << MISO_pin);
    uint32_t pinDefault_mask = (0 << SCLK_pin) | (0 << MOSI_pin);
    pio_sm_set_pins_with_mask(pio, sm, pinDefault_mask, pin_mask);
    pio_sm_set_pindirs_with_mask(pio, sm, pindir_mask, pin_mask);
    pio_gpio_init(pio, SCLK_pin);
    pio_gpio_init(pio, MISO_pin);
    pio_gpio_init(pio, MOSI_pin);
    gpio_init(CS_pin);
    gpio_set_dir(CS_pin, GPIO_OUT);
        // initialize + enable pio sm
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, false);
}
static inline void SPI_Byte_Master_w(PIO pio, uint sm, uint CS_pin,
        uint8_t* src, size_t len
) {
    io_rw_8* txfifo = (io_rw_8*)(&pio->txf[sm]);
    io_rw_8* rxfifo = (io_rw_8*)(&pio->rxf[sm]);
    gpio_put(CS_pin, 0);
    size_t txRemaining = len, rxRemaining = len;
    while(txRemaining || rxRemaining) {
        if (txRemaining && !pio_sm_is_tx_fifo_full(pio, sm)) {
            *txfifo = *src++;
            txRemaining--;
        }
        if (rxRemaining && !pio_sm_is_rx_fifo_empty(pio, sm)) {
            (void) *rxfifo;
            rxRemaining--;
        }
    }
    gpio_put(CS_pin, 1);
}
static inline void SPI_Byte_master_rw(PIO pio, uint sm, uint CS_pin,
        uint8_t* src, uint8_t* dest, size_t len
) {
    io_rw_8* txfifo = (io_rw_8*)(&pio->txf[sm]);
    io_rw_8* rxfifo = (io_rw_8*)(&pio->rxf[sm]);
    gpio_put(CS_pin, 0);
    size_t txRemaining = len, rxRemaining = len;
    while(txRemaining || rxRemaining) {
        if (txRemaining && !pio_sm_is_tx_fifo_full(pio, sm)) {
            *txfifo = *src++;
            txRemaining--;
        }
        if (rxRemaining && !pio_sm_is_rx_fifo_empty(pio, sm)) {
            *dest++ = *rxfifo;
            rxRemaining--;
        }        
    }
    gpio_put(CS_pin, 1);
}

#endif

// -------------- //
// SPI_Byte_Slave //
// -------------- //

#define SPI_Byte_Slave_wrap_target 2
#define SPI_Byte_Slave_wrap 8
#define SPI_Byte_Slave_pio_version 0

static const uint16_t SPI_Byte_Slave_program_instructions[] = {
    0xe020, //  0: set    x, 0
    0x20a2, //  1: wait   1 pin, 2
            //     .wrap_target
    0x2022, //  2: wait   0 pin, 2
    0x8080, //  3: pull   noblock
    0x2021, //  4: wait   0 pin, 1
    0x6001, //  5: out    pins, 1
    0x20a1, //  6: wait   1 pin, 1
    0x4001, //  7: in     pins, 1
    0x00e4, //  8: jmp    !osre, 4
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program SPI_Byte_Slave_program = {
    .instructions = SPI_Byte_Slave_program_instructions,
    .length = 9,
    .origin = -1,
    .pio_version = SPI_Byte_Slave_pio_version,
#if PICO_PIO_VERSION > 0
    .used_gpio_ranges = 0x0
#endif
};

static inline pio_sm_config SPI_Byte_Slave_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + SPI_Byte_Slave_wrap_target, offset + SPI_Byte_Slave_wrap);
    return c;
}

static inline void SPI_Byte_Slave_init(
        PIO pio, uint sm, uint offset,
        uint SCLK_pin, uint MOSI_pin, uint MISO_pin, uint CS_pin,
        uint baud,
        bool full_duplex
) {
        // input validation
    assert(SCLK_pin == MOSI_pin + 1);
    assert(CS_pin == MOSI_pin + 2);
        // get default config
    pio_sm_config c = SPI_Byte_Slave_program_get_default_config(offset);
        // set in/out pins and shift
    sm_config_set_out_pins(&c, MISO_pin, 1);
    sm_config_set_in_pins(&c, MOSI_pin);
    sm_config_set_in_pin_count(&c, 3);
    sm_config_set_out_shift(&c, false, false, 8);
    sm_config_set_in_shift(&c, false, true, 8);
        // set clkdiv
        // initialize pins
    uint32_t pin_mask = (1 << SCLK_pin) | (1 << MOSI_pin) | (1 << MISO_pin) | (1 << CS_pin);
    uint32_t pindir_mask = (0 << SCLK_pin) | (0 << MOSI_pin) | (1 << MISO_pin) | (0 << CS_pin);
    uint32_t pinDefault_mask = (0 << MISO_pin);
    pio_sm_set_pins_with_mask(pio, sm, pinDefault_mask, pin_mask);
    pio_sm_set_pindirs_with_mask(pio, sm, pindir_mask, pin_mask);
    pio_gpio_init(pio, SCLK_pin);
    pio_gpio_init(pio, MISO_pin);
    pio_gpio_init(pio, MOSI_pin);
    pio_gpio_init(pio, CS_pin);
        // initialize + enable pio sm 
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}
static inline size_t SPI_Byte_Slave_r(PIO pio, uint sm, uint CS_pin,
        uint8_t* dest, size_t max_len
) {
    io_rw_8* rxfifo = (io_rw_8*)(&pio->rxf[sm]);
    size_t len = 0;
    while (gpio_get(CS_pin)) { tight_loop_contents(); }
    while (!gpio_get(CS_pin)) {
        if (len < max_len && !pio_sm_is_rx_fifo_empty(pio, sm)) {
            *dest++ = *rxfifo;
            len++;
        }
        if (len >= max_len && !pio_sm_is_rx_fifo_empty(pio, sm)) {
            (void) *rxfifo;
        }
    }
    return len;
}

#endif

