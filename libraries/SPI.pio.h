// ---------------------------------------------------------------- //
// This file is autogenerated by pioasm version 2.2.0; do not edit! //
// ---------------------------------------------------------------- //

#pragma once

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

// ---------- //
// SPI_Master //
// ---------- //

#define SPI_Master_wrap_target 0
#define SPI_Master_wrap 1
#define SPI_Master_pio_version 0

static const uint16_t SPI_Master_program_instructions[] = {
            //     .wrap_target
    0x6001, //  0: out    pins, 1         side 0
    0x5001, //  1: in     pins, 1         side 1
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program SPI_Master_program = {
    .instructions = SPI_Master_program_instructions,
    .length = 2,
    .origin = -1,
    .pio_version = SPI_Master_pio_version,
#if PICO_PIO_VERSION > 0
    .used_gpio_ranges = 0x0
#endif
};

static inline pio_sm_config SPI_Master_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + SPI_Master_wrap_target, offset + SPI_Master_wrap);
    sm_config_set_sideset(&c, 1, false, false);
    return c;
}
#endif

// --------- //
// SPI_Slave //
// --------- //

#define SPI_Slave_wrap_target 0
#define SPI_Slave_wrap 4
#define SPI_Slave_pio_version 0

static const uint16_t SPI_Slave_program_instructions[] = {
            //     .wrap_target
    0x2022, //  0: wait   0 pin, 2
    0x2021, //  1: wait   0 pin, 1
    0x6001, //  2: out    pins, 1
    0x20a1, //  3: wait   1 pin, 1
    0x4001, //  4: in     pins, 1
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program SPI_Slave_program = {
    .instructions = SPI_Slave_program_instructions,
    .length = 5,
    .origin = -1,
    .pio_version = SPI_Slave_pio_version,
#if PICO_PIO_VERSION > 0
    .used_gpio_ranges = 0x0
#endif
};

static inline pio_sm_config SPI_Slave_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + SPI_Slave_wrap_target, offset + SPI_Slave_wrap);
    return c;
}

#include "hardware/clocks.h"
static inline void SPI_Master_init(
        PIO pio, uint sm, uint offset,
        uint SCLK_pin, uint MOSI_pin, uint MISO_pin, uint CS_pin, 
        uint baud, uint frame_size
) {
        // get default config
    pio_sm_config c = SPI_Master_program_get_default_config(offset);
        // set in/out pins and shift
    sm_config_set_out_pins(&c, MOSI_pin, 1);
    sm_config_set_in_pins(&c, MISO_pin);
    sm_config_set_in_pin_count(&c, 1);
    sm_config_set_sideset_pins(&c, SCLK_pin);
    sm_config_set_out_shift(&c, false, true, frame_size);
    sm_config_set_in_shift(&c, false, true, frame_size);
        // set clkdiv
    float clkdiv = clock_get_hz(clk_sys) / (baud * frame_size * 2.0);
    sm_config_set_clkdiv(&c, clkdiv);
        // initialize pins
    uint32_t pin_mask = (1 << SCLK_pin) | (1 << MOSI_pin) | (1 << MISO_pin);
    uint32_t pindir_mask = (1 << SCLK_pin) | (1 << MOSI_pin) | (0 << MISO_pin);
    uint32_t pinDefault_mask = (0 << SCLK_pin) | (0 << MOSI_pin);
    pio_sm_set_pins_with_mask(pio, sm, pinDefault_mask, pin_mask);
    pio_sm_set_pindirs_with_mask(pio, sm, pindir_mask, pin_mask);
    pio_gpio_init(pio, SCLK_pin);
    pio_gpio_init(pio, MISO_pin);
    pio_gpio_init(pio, MOSI_pin);
    gpio_init(CS_pin);
    gpio_set_dir(CS_pin, GPIO_OUT);
        // initialize + enable pio sm
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, false);
}
static inline void SPI_Master_raw_write(
        PIO pio, uint sm, uint32_t raw
) {
    pio_sm_put_blocking(pio, sm, raw);
    pio_sm_get_blocking(pio, sm);
}
static inline void SPI_Master_write(
    PIO pio, uint sm, uint32_t data, uint frame_size
) {
    pio_sm_put_blocking(pio, sm, data << (32 - frame_size));
    pio_sm_get_blocking(pio, sm);
}
static inline void SPI_Slave_init( 
        PIO pio, uint sm, uint offset,
        uint SCLK_pin, uint MOSI_pin, uint MISO_pin, uint CS_pin,
        uint baud, uint frame_size
) {
        // input validation
    assert(SCLK_pin == MOSI_pin + 1);
    assert(CS_pin == MOSI_pin + 2);
        // get default config
    pio_sm_config c = SPI_Slave_program_get_default_config(offset);
        // set in/out pins and shift 
    sm_config_set_out_pins(&c, MOSI_pin, 1);
    sm_config_set_in_pins(&c, MISO_pin);
    sm_config_set_in_pin_count(&c, 3);
    sm_config_set_out_shift(&c, false, true, frame_size);
    sm_config_set_in_shift(&c, false, true, frame_size);
        // set clkdiv
    float clkdiv = clock_get_hz(clk_sys) / (baud * frame_size * 2.0 * 4.0);
    sm_config_set_clkdiv(&c, clkdiv);
        // initialize pins
    uint32_t pin_mask = (1 << SCLK_pin) | (1 << MOSI_pin) | (1 << MISO_pin) | (1 << CS_pin);
    uint32_t pindir_mask = (0 << SCLK_pin) | (0 << MOSI_pin) | (1 << MISO_pin) | (0 << CS_pin);
    uint32_t pinDefault_mask = (0 << MISO_pin);
    pio_sm_set_pins_with_mask(pio, sm, pinDefault_mask, pin_mask);
    pio_sm_set_pindirs_with_mask(pio, sm, pindir_mask, pin_mask);
    pio_gpio_init(pio, SCLK_pin);
    pio_gpio_init(pio, MISO_pin);
    pio_gpio_init(pio, MOSI_pin);
    pio_gpio_init(pio, CS_pin);
        // initialize + enable pio sm
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, false);
}
static inline void SPI_Slave_raw_read(
        PIO pio, uint sm, uint32_t* raw
) {
    pio_sm_put_blocking(pio, sm, 0);
    *raw = pio_sm_get_blocking(pio, sm);
}
static inline void SPI_Slave_read(
        PIO pio, uint sm, uint32_t* dest, uint frame_size
) {
    pio_sm_put_blocking(pio, sm, 0);
    *dest = pio_sm_get_blocking(pio, sm);
}

#endif

